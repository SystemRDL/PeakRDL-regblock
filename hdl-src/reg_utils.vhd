library ieee;
context ieee.ieee_std_context;

-- Convenience types and utility functions used by the autogenerated regblock code
package reg_utils is

  type std_logic_array1 is array(natural range<>) of std_logic;
  type std_logic_array2 is array(natural range<>, natural range<>) of std_logic;
  type std_logic_array3 is array(natural range<>, natural range<>, natural range<>) of std_logic;
  type std_logic_array4 is array(natural range<>, natural range<>, natural range<>, natural range<>) of std_logic;
  type std_logic_array5 is array(natural range<>, natural range<>, natural range<>, natural range<>, natural range<>) of std_logic;

  type std_logic_vector_array1 is array(natural range<>) of std_logic_vector;
  type std_logic_vector_array2 is array(natural range<>, natural range<>) of std_logic_vector;
  type std_logic_vector_array3 is array(natural range<>, natural range<>, natural range<>) of std_logic_vector;
  type std_logic_vector_array4 is array(natural range<>, natural range<>, natural range<>, natural range<>) of std_logic_vector;
  type std_logic_vector_array5 is array(natural range<>, natural range<>, natural range<>, natural range<>, natural range<>) of std_logic_vector;

  -- reverse bits of the input vector
  function bitswap(vec: in std_logic_vector) return std_logic_vector;
  function bitswap(logic: in std_logic) return std_logic;

  -- Autogenerating VHDL when dealing with programmatically defined field widths
  -- can be challenging, especially when doing arithmetic. These conversion functions
  -- are overloaded with various input types, allow them to work regardless
  -- of the input type or width.
  function to_unsigned(vec: in std_logic_vector) return unsigned;
  function to_unsigned(logic: in std_logic) return unsigned;

  function to_std_logic_vector(uns: in unsigned) return std_logic_vector;
  function to_std_logic_vector(logic: in std_logic) return std_logic_vector;

  function to_std_logic(bool: in boolean) return std_logic;
  function to_std_logic(vec: in std_logic_vector(0 downto 0)) return std_logic;
  function to_std_logic(uns: in unsigned(0 downto 0)) return std_logic;

end package reg_utils;

package body reg_utils is

    function bitswap(vec: in std_logic_vector) return std_logic_vector is
        variable result: std_logic_vector(vec'RANGE);
        alias swapped: std_logic_vector(vec'REVERSE_RANGE) is vec;
    begin
        for i in swapped'RANGE loop
            result(i) := swapped(i);
        end loop;
        return result;
    end function;

    function bitswap(logic: in std_logic) return std_logic is
    begin
        return logic;
    end function;

    function to_unsigned(vec: in std_logic_vector) return unsigned is
    begin
        return unsigned(vec);
    end function;

    function to_unsigned(logic: in std_logic) return unsigned is
        variable result: unsigned(0 downto 0);
    begin
        result(0) := logic;
        return result;
    end function;

    function to_std_logic_vector(uns: in unsigned) return std_logic_vector is
    begin
        return std_logic_vector(uns);
    end function;

    function to_std_logic_vector(logic: in std_logic) return std_logic_vector is
        variable result: std_logic_vector(0 downto 0);
    begin
        result(0) := logic;
        return result;
    end function;

    function to_std_logic(bool: in boolean) return std_logic is
    begin
        if bool = TRUE then
            return '1';
        else
            return '0';
        end if;
    end function;

    function to_std_logic(vec: in std_logic_vector(0 downto 0)) return std_logic is
    begin
        return vec(0);
    end function;

    function to_std_logic(uns: in unsigned(0 downto 0)) return std_logic is
    begin
        return uns(0);
    end function;

end package body;